{
  "name": "fast-stats",
  "version": "0.0.1",
  "description": "Quickly calculate common statistics on lists of numbers",
  "keywords": [
    "statistics",
    "statistic",
    "gauss",
    "lognormal",
    "normal",
    "mean",
    "median",
    "mode",
    "standard deviation",
    "margin of error",
    "iqr",
    "quartile",
    "inter quartile range"
  ],
  "homepage": "https://github.com/bluesmoon/node-faststats",
  "author": {
    "name": "Philip Tellis",
    "email": "philip@bluesmoon.info",
    "url": "http://bluesmoon.info/"
  },
  "main": "faststats.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/bluesmoon/node-faststats.git"
  },
  "readme": "Fast Statistics\n===============\n\nA NodeJS library to do statistical analysis of numeric datasets.\n\nintroduction\n------------\n\nWhen doing statistical analysis of data, the most common usage pattern is to run multiple statistical methods on the same set\nof data.  Some of these methods use others.  For example, to calculate the standard deviation of a dataset, we first need the\nmean.\n\nAdditionally, some methods can be calculated quickly as data is inserted, thereby reducing the number of loops required to\nrun through the data during processing.\n\nFast stats maintains a running cache of several summary values as data is inserted making final calculation very fast.  It\ntrades off a small amount of additional memory usage for a large reduction in execution time.\n\ndownsides\n---------\n\nThe downside of how fast stats operates is that if your datapoints are too large, it may result in numeric overflow causing\nincorrect results.  Fast stats does not attempt to detect or correct for this.\n\nsynopsis\n--------\n\n```javascript\nvar Stats = require('fast-stats').Stats;\n\nvar s = new Stats(1, 2, 3, 10, 8, 4, 3);\nconsole.log(s.amean().toFixed(2));\n// 4.43\n```\n\ninstallation\n------------\n\n    $ npm install fast-stats\n\nAPI\n---\n\nfast-stats is completely synchronous.  There are no blocking methods and consequently no callbacks involved.  All\nruntime calls are executed in-memory and are fast.\n\n### Getting data in and out\n\n#### Initialising and adding data\n\nThe `Stats` constructor looks a lot like an array in the way you add and remove data to its ends, however there is\nno direct access to individual elements.  The constructor takes in multiple values or a single list of values.  All\nvalues must be numbers and behaviour is undefined if they are not.\n\nAdditionally, the `push()` method may take in a list of values that will be added to the end of the current list and\nthe `unshift()` method may take in a list of values that will be added to the beginning of the list.\n\nThe following are equivalent.\n\n```javascript\nvar s1, s2, s3, s4;\ns1 = new Stats(1, 2, 3, 10, 8, 4, 3);\n\ns2 = new Stats([1, 2, 3, 10, 8, 4, 3]);\n\ns3 = new Stats();\ns3.push(1, 2, 3, 10, 8, 4, 3);\n\ns4 = new Stats();\ns4.unshift(1, 2, 3, 10, 8, 4);\ns4.push(3);\n\nassert.equal(s1.amean().toFixed(2), s2.amean().toFixed(2));\nassert.equal(s1.amean().toFixed(2), s3.amean().toFixed(2));\nassert.equal(s1.amean().toFixed(2), s4.amean().toFixed(2));\n```\n\nNote that we use the `toFixed()` method of the Number class when comparing numbers.  Remember that even if you\npass in integers, values like the arithmetic mean, standard deviation and median can sometimes be floating point\nnumbers, and two floating point numbers may not necessarily be equal to the last decimal point.  The `toFixed()`\nmethod is useful to restrict how precise we want our comparison to be.  Be aware that it returns a string though.\n\n`fast-stats` does not use the `toFixed()` method internally.\n\nThe `push()` and `unshift()` methods return the new length of the object.\n\n#### Removing data\n\nIf you need to remove data from a `Stats` object, use the `pop()` and `shift()` methods.  Their semantics are the\nsame as the `pop()` and `shift()` methods of Arrays.\n\n```javascript\nvar a = s1.pop();\nassert.equal(a, 3);\n\nvar b = s2.shift();\nassert.equal(b, 1);\n\nassert.equal(s1.length, 6);\nassert.equal(s2.length, 6);\nassert.ok(s1.amean() < s2.amean());\n```\n\n#### Clearing all data\n\nThe `reset()` method clears out all data.\n\n```javascript\ns4.reset();\nassert.equal(s4.length, 0);\n```\n\nThe `reset()` method returns a reference to the object, so you can chain methods.\n\n#### Making a copy\n\nThe `copy()` method returns a copy of the current Stats object.\n\n```javascript\ns4 = s3.copy();\n\nassert.equal(s1.length, s2.length);\n```\n\n### Summaries & Averages\n\nThe term _Average_ is overloaded in Statistics.  It relates to a summary of a data set, but says nothing about how\nwe arrived at that summary.  There are many ways to summarise data, including the arithmetic mean, geometric mean,\nharmonic mean, median, mode and more.  `fast-stats` implements the Arithmetic Mean, the Geometric Mean and the Median.\nIt also implements a percentile method to get at any percentile of the data.\n\n#### Arithmetic Mean\n\nThe arithmetic mean is calculated as the sum of all data points divided by the number of data points.  This is useful\nfor data sets that are fairly uniform, following a linear or binomial distribution.  Use the `amean()` method or the `μ()`\nmethod to get at it:\n\n```javascript\nvar a = s1.amean();\nassert.equal(a.toFixed(2), \"4.67\");   // remember we popped out the last item of `s1` above.\n```\n\n#### Geometric Mean\n\nThe arithmetic mean is the `n`th root of the product of all data points where n is the number of data points. This is useful\nfor data sets that follow an exponential or log-normal distribution.  Use the `gmean()` method to get at it:\n\n```javascript\nvar a = s1.gmean();\nassert.equal(a.toFixed(2), \"3.53\");\n```\n\n#### Median\n\nThe median is the middle point of the dataset when sorted in ascending order.  This is useful if your dataset has a lot of\noutliers and noise that would not normally be found in a complete population.  Use the `median()` method to get at it:\n\n```javascript\nvar a = s1.median();\nassert.equal(a.toFixed(2), \"3.50\");\n```\n\nIf your data set contains an odd number of points, the median will be the middle point.  If it contains an even number of\npoints, then the median will be the arithmetic mean of the two middle points.\n\n#### Any Percentile\n\nYou can also get at any percentile value within the data.  Use the `percentile()` method to get at this data.  The\n`percentile()` method takes in a single argument.  This is a number between 0 and 100 (both inclusive) that specifies\nwhich percentile point you want.\n\n```javascript\nvar p95 = s1.percentile(95);\nvar m = s1.percentile(50);\nvar q1 = s1.percentile(25);\n\nassert.equal(p95.toFixed(2), \"10.00\");\nassert.equal(m.toFixed(2), \"3.50\");\nassert.equal(q1.toFixed(2), \"2.50\");\n```\n\nPassing in 50 as an argument will return the median, while 25 and 75 will return the first and third quartiles respectively.\nThese three special values may be arithmetic means of two other values within the set.  All other arguments will return a\nnumber from the data set.\n\n#### Range\n\nThe `range()` method tells you the minimum and maximum values of your data set.  It returns an array of two values.  The\nfirst is the lower bound and the second is the upper bound.\n\n```javascript\nvar r = s1.range();\n\nassert.equal(r.length, 2);\nassert.equal(r[0], 1);\nassert.equal(r[1], 10);\n```\n\n\n### Data Accuracy\n\nThere are various statistical values that tell you how accurate or uniform your data is.  `fast-stats` implements\nthe Arithmetic Standard Deviation, Geometric Standard Deviation and 95% Confidence Interval Margin of Error.\n\n#### Arithmetic Standard Deviation\n\nAlso commonly just called the Standard Deviation, with the symbol σ.  This tells you the spread of your data if\nit follows a normal (or close to normal) distribution, ie, the bell curve.  `fast-stats` is really fast at\ncalculating the standard deviation of a dataset.  Use the `stddev()` method or the `σ()` method to get at it.\n\n```javascript\nvar sd = s1.σ();\n\nassert.equal(sd.toFixed(2), '3.25');\n```\n\nThe arithmetic standard deviation is used in conjunction with the arithmetic mean to tell you the spread of your\ndataset: `[amean-stddev, amean+stddev]`.  Note that you could also use 2 or 3 standard deviations for different\nspreads.\n\n#### Geometric Standard Deviation\n\nThe geometric mean tells you the spread of your data if it follows a log-normal or exponential distribution.\nUse the `gstddev()` method to get at it.\n\n```javascript\nvar gsd = s1.gstddev();\n\nassert.equal(gsd.toFixed(2), '2.20');\n```\n\nThe geometric standard deviation is used in conjunction with the geometric mean to tell you the spread of your\ndataset: `[gmean/gstddev, gmean*gstddev]`.  Note that this range is not symmetric around the geometric mean.\n\n#### 95% Confidence Margin of Error\n\nThe Margin of Error value tells you the range within which the real arithmetic mean of the population is likely to\nbe with 95% confidence.  Use the `moe()` method to get at it.\n\n```javascript\nvar moe = s1.moe();\n\nassert.equal(moe.toFixed(2), '2.60');\n```\n\nThis value suggests that we are 95% certain that the real mean of the population is within 2.60 of the calculated \narithmetic mean of 4.67.  We could use this to find out the percent error in our sample.  In this case there is a\n55.71% error.\n\nThe margin of error is inversely proportional to the square root of the number of data points, so increasing the\nsize of your sample will reduce the margin of error.  It is good to strive for a margin of error of less than 5%.\n\n### Data filtering\n\nWhen dealing with statistical samples, it may be necessary to filter the dataset to get rid of outliers.  Sometimes\nan outlier is fairly obvious, and you can specify an upper and lower limit for it.   At other times, outliers are\nonly apparent when looking at the rest of the dataset.  Inter-Quartile-Range filtering is useful to filter out these\nkinds of data sets.\n\n#### Band-pass filtering\n\nThe `band_pass()` filter method returns a new `Stats` object with all its data points within the specified range.\nThis method takes in three arguments.  The first is the lower bound of the range, the second is the upper bound\nof the range.  Both these arguments are required.\n\nThe third argument specifies whether the range is open or closed.  An open range does not include the upper and\nlower bounds while a closed range includes them.  If not specified (or set to `false`), the range is closed.  If\nset to `true` the range is open.\n\n```javascript\nvar s5 = s1.band_pass(3, 8);\nvar r = s5.range();\n\nassert.equal(r[0], 3);\nassert.equal(r[1], 8);\n\ns5 = s1.band_pass(3, 8, true);\nr = s5.range();\n\nassert.equal(r[0], 4);\nassert.equal(r[1], 4);\n```\n\nBand pass filtering should be used if the range for your data is rigid and never changes.\n\n#### IQR Filtering\n\nIQR, or Inter Quartile Range filtering filters data based on the spread of the data.  It is much more adaptive to\nchanges in data ranges.  Use the `iqr()` method to IQR filter a dataset.  The `iqr()` method does not accept\nany arguments.\n\n\n```javascript\nvar s6 = s1.iqr();\nr = s6.range();\n\nassert.equal(r[0], 1);\nassert.equal(r[1], 10);\n```\n\nIn some cases, IQR filtering may not filter out anything.  This can happen if the acceptable range is wider than\nthe bounds of your dataset.\n\n\nReferences\n----------\n\nWikipedia is a great place to get information about Statistical functions.\n\nCopyright\n---------\n\n`fast-stats` is Copyright 2011 Philip Tellis <philip@bluesmoon.info> and the latest version of the code is\navailable at https://github.com/bluesmoon/node-faststats\n\nLicense\n-------\n\nApache 2.0.  See the [LICENSE](https://github.com/bluesmoon/node-faststats/blob/master/LICENSE) file for details.\n",
  "_id": "fast-stats@0.0.1",
  "_from": "fast-stats@"
}
